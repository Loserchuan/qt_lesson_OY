<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <input type="text" id="txt">
        <p id="show-txt"></p>
    </div>
    <script>

        // // 传统写法
        const texEle = document.getElementById('show-txt')
        const oInput = document.getElementById('txt')
        // document.getElementById('txt').addEventListener('input', function() {
        //     texEle.innerHTML = this.value; // 这里change事件不合适 input事件更合适
        //     obj.txt = this.value
        // })

        // // 值和显示的双向绑定
        // const obj = {
        //     txt: '纳德拉'
        // }

        // function init() {
        //     rander(obj.txt)
        //     setTimeout(function() {
        //         obj.txt = '甘地'
        //         rander(obj.txt)
        //     }, 1000)
        // }
        // init();

        // function rander(txt) {
        //     oInput.value = txt
        //     texEle.innerHTML = txt
        // }


        // 这个页面(静态)的数据(data)核心
        // 保证数据和界面的双向绑定
        // 1.函数封装的思想 大于10行的函数代码 请拿出来重新封装另一个函数 每个函数只做一件事 封装完毕之后可以复用
        const obj = {
            _txt: '纳德拉'
        }

        Object.defineProperty(obj, 'txt', {
            get: function() {
                console.log('获得属性')
                return this._txt;
            }
            /* set: function(newValue) {
                console.log('设置属性');
                oInput.value = newValue
                texEle.innerHTML = newValue
            } */
        })
        
        setTimeout(() => {
            obj.txt
        }, 3000)
        /* document.getElementById('txt').addEventListener('keyup', function(e) {
            obj.txt = e.target.value;
        }) */

    </script>
</body>

</html>