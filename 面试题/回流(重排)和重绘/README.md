## 浏览器渲染的过程
1. 解析HTML, 生成Dom树, 生成cssom树
2. 将Dom和cssom树结合, 生成渲染树(render tree)
3. 回流(重排): 根据生成的渲染树进行回流 得到节点的几何信息 (只包含位置和大小, 不包括颜色等其他) 比如修改元素的宽、高或隐藏元素等
4. 重绘: 根据渲染树和节点的几何信息 得到节点的绝对像素
5. 将像素发给GPU, 展示在页面上(GPU画图操作)

## 何时执行回流重绘
1. 添加或删除 可见的 Dom元素
2. 元素的位置和大小发生变化的时候 (包括内容改变造成容器变化)
3. 浏览器窗口大小发生改变
4. 页面初次渲染

## 注意：回流一定会触发重绘，而重绘(非几何信息的样式发生改变)不一定会回流, reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；

## 回流比重绘的代价要更高。
有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。
现代浏览器会对频繁的回流或重绘操作进行优化：
浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

## 当你访问以下属性或方法时 浏览器会立刻清空队列 强制队列刷新
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
width、height
getComputedStyle()
getBoundingClientRect()

因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

## 如何减少回流和重绘的次数
1. 使元素脱离文档流
2. 对其对其多次修改
3. 将元素带回文档流中

## 让Dom脱离文档流的三种方式
1. 隐藏元素 display: none; 在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
2. 使用文档片段 (document fragment) 在当前的Dom之外构建一个子树 再把它拷贝进文档
3. 将原始元素拷贝到一个脱离文档的节点中 修改节点后 再替换原始元素